---
layout: post
title:  "Wireless Networks"
date:   2021-4-14 00:00:00 -0500
tags: [networking]
---



# Introduction

Using WiFi really only changes the link layer, everything else in the network can remain the same. When using a wireless connection, we have to deal with the signal attenuating (as distance increases or when there are objects obstructing the path), interference from other signals, and multipath propagation (when signals bounce off surfaces and arrive at different times which causes the host to receive signals that are muddled). For these reasons, wireless connections make use of CRC codes (briefly introduced in the last post) and use reliable transmission.

WiFi is standardized in IEEE 802.11 which is actually a whole family of standards. All WiFi versions share a lot of the same building blocks: their medium access protocol, CSMA/CA (discussed below), frame structure, etc. They are all backwards compatible.

# How WiFi Works

WiFi APs (access points, the little box that beams out WiFi) occasionally broadcast **beacon frames** which contain the AP's MAC address and **service state ID (SSID)** which is the name of the WiFi network. Devices scan the different WiFi channels, looking for these beacon frames. There is no set way for a device to choose a specific AP but in general devices pick the AP with the greatest signal strength. This is known as passive scanning. There is also active scanning where a device sends out a probe and the APs that receive it send back a response. Either way, once the device picks an AP, it sends out a request and the AP replies by accepting the device.

The multiple access protocol was chosen to be a random access protocol due to the success of Ethernet. 802.11 uses **carrier sense multiple access with collision avoidance (CSMA/CA)**. To discuss this, I first want to note that 802.11 uses an ACK scheme: when a device sends a frame and the AP receives it, the AP waits for a short period of time known as the **short inter-frame spacing (SIFS)** and then sends an ACK frame back. If the sending device doesn't receive an ACK in a certain amount of time, it sends the frame again.

So here's CSMA: say a device notices that the airwaves are empty. Then it waits for a period of time known as the **distributed inter-frame spacing (DIFS)** and then transmits its frame. Collision detection over wireless is hard for a number of reasons that I don't want to get into but suffice it to say, once a device begins transmitting a frame it will transmit that frame in its entirety. If the channel isn't empty then the device uses exponential back off to choose an amount of time to wait. The device waits as long as that amount of time + the DIFS, freezing the timer whenever the channel is in use, and only once the timer reaches 0 does it send a frame. If the ACK isn't received and the device times out, then we jump back to assuming the airwaves aren't clear and picking a new exponential back off (this time from a larger distribution). There is a, rarely used, option to request permission to transmit from the AP. The AP will then broadcast a message saying it's that device's turn to talk, ensuring there are no collisions.

The headers for WiFi are pretty complicated and I'm not planning on diving too in-depth on them but I'll give the topline information. The headers begin with 2 bytes of frame control: 2 bits protocol version, 2 bits type, 4 bits subtype (type and subtype tell us things like this is an ACK frame), then 1 bit each for to-field, from-field, something called "more frag", retry, power management (detailed below), more data, WEP (whether or not encryption is on), and reserved. This is followed by a 2-byte duration (for the uncommon option of reserving the channel). After this come three MAC addresses: the first is the destination (of the next hop, not the final destination), the second is the sender, the third is the router (which is usually the same as the AP in home networks). The gist of why address 3 is needed is because the AP is essentially a link-layer switch and so the frame should technically be sent directly to the router but unfortunately the router doesn't speak wireless. After that comes a 2-byte sequence number which serves the same purpose as in the transport layer (e.g., if an ACK is lost and the device retransmits, no problem). Then comes a fourth MAC address which is used when there is no AP (for decentralized networks that I'm not going to talk about other than briefly in the Bluetooth section). Then comes the payload which can be any size up to 2,312 bytes but in practice it's kept smaller than 1,500. Then comes a 4-byte CRC code.

There is no really great way to handle a device moving onto a new AP. If these APs are connected by a router then there's really nothing to be done as they will have different IPs and any TCP connection will break. If instead they are connected by a switch, they can be on the same subnet. This allows a device to keep it's same IP. In order for the switch to learn a device has changed APs, when the AP gets a new device, it broadcasts this fact to the switch which then updates it's routing table.

WiFi also has some advanced options that aren't fully laid out in the specification but are for vendors to decide how to implement. For example, it's often the case that if two frames in a row fail to receive an ACK, the device will transmit at a slower frequency (decreasing the chance of an error); if 10 frames in a row are received correctly, or if it's been so long since the last frame failed to ACK, the device will use a higher frequency.

Devices can also set the power management bit to 1 which tells the AP that the device's wireless adapter is going to sleep. The device will wake up every 100ms in order to receive the AP's beacon frame (recall that the AP broadcasts this). The beacon frame includes a list of the devices who have messages waiting at the AP. Those device then contact the AP and get all of their buffered data. The devices without data waiting at the AP go back to sleep. Sleeping and waking up are so fast that devices can actually sleep for more than 99% of the time which greatly improves battery life.

# Bluetooth

Bluetooth is defined in IEEE 802.15.1. It uses TDM (see [here](https://william-frazier.github.io/2021-01-04-Networking-Terms/) for a post that talks about this) with timeslots of 625 microseconds. There are 79 channels and they change around in a known, pseudo-random way so that transmissions are spread over the spectrum. Bluetooth is much slower and closer-range (making it cheaper and using less power) providing speeds of only up to 4Mbps.

Bluetooth devices arrange themselves in a network called a **piconet** which can have up to 8 devices. This is a type of **ad-hoc** network where there is no infrastructure (e.g., no AP needed). In this network there is a master device (with the other 7 devices being unfortunately called slaves). Obviously, these names need to change. My understanding is that there is some push to call mater nodes "central nodes" and slave nodes "peripheral nodes". I don't know how common this terminology is yet but it's what I'll use in this post for obvious reasons. The central node can set the clock time and may transmit in any odd numbered time slot while peripheral nodes can only speak if the central node spoke to them in the previous time slot and can only talk to the central node. There can also be up to 255 "parked" devices which can't do anything unless the central node activates them.

There is an even slower and low-powered thing that is similar to Bluetooth called Zigbee (IEEE 802.15.4). It's used for things like light sensors, wall-mounted switches, and security devices. It has channel rates of 20, 40, 100, and 250 Kbps. Zigbee has full-function and reduced function devices which are equivalent to Bluetooth's central and peripheral nodes. The full-function devices can communicate amongst themselves and make a mesh network.

# Mobility

For devices that are mobile, we associate them with a network, called their **home network**. When the device is on some other network, we call that their **foreign network**. If we want a host to be able to keep the IP address that it uses on its home network while it is on the foreign network, we're going to have to do some work. One possibility is to just have the foreign network update the network's routing tables by saying this one specific IP should be routed to itself. Because of the longest-prefix rule, this will work and traffic will make it to the mobile device. But this approach isn't scalable. So instead, we want the home network to be able to track the device. What we do is get the foreign network (or perhaps the host will use DHCP) to assign the mobile device a new address called the **care-of-address (COA)** or the **foreign address** which is within the foreign network. The COA will then be sent to the home network. Note that the foreign network doesn't need to worry about deregistering a COA when the host leaves because when the host arrives at a new network, that network will register a new COA with the home network.

There are two ways we can route now. The first is indirect routing. Here, when a device (called the correspondent) wants to communicate with a mobile device which has moved networks, the correspondent sends the message as usual to the home network. The home network will notice that device is on a foreign network and will encapsulated the datagram in a new datagram with the IP set to the COA. When the mobile host wants to communicate with the correspondent, it simply adds its home address as the sender's address. This way, it looks to the correspondent like this host is still at the same original IP. Clearly, this isn't the most efficient system. Consider if I travelled from the East coast to the West coast and was trying to communicate with a device on the same West coast network: packets would have to be sent from the West coast to my home network on the East coast and then forwarded back to the West coast.

So we can instead use the second form of routing which is direct routing. Here, when a correspondent sends data to the home network expecting to find the host, the home network will reply with the host's COA. Now the correspondent can encapsulate the IP datagram in a new datagram with the COA as the destination. This becomes even more complex if the mobile user now goes to yet another new network. Because the correspondent asked the home network for the COA only once, it's unaware of this newest change of address. In this case, we do something like indirect routing where the original foreign network will send encapsulate and send packets onto this newest network.

# Next Steps

I really wanted to talk about cellular networks but I have had trouble finding good sources on the topic. I'm sure they're out there but I haven't found them yet. Right now, the plan is for the next post to be about streaming video. I don't think this post will be all that long mainly because I don't find the topic interesting as much as I do important.
