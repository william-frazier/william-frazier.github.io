---
layout: post
title:  "Network Layer Pt. 1: The Data Plane"
date:   2021-2-8 00:00:00 -0500
tags: [networking]
---

# Introduction

There are 2 main functions that the network layer performs, routing (handled by the control plane) and forwarding (also called switching) which is what I want to talk about in this post. **Forwarding** is the process of transferring a packet from the router's input interface to its output interface. This typically takes only nanoseconds and is generally implemented in hardware. An **interface** is the boundary between a machine and a physical link. Technically, an IP address is mapped to an interface rather than a machine. **Routing** is the network-wide process of determining the path a packet will take. Routing typically takes a few seconds and is implemented in software.

Every network router has something called a **forwarding table**. This is a table which maps packet headers to output link interfaces. When a packet arrives, it is indexed in the table to see which interface it should be forwarded to. This is known as **next-hop routing**. How these tables are filled will be discussed in my next post but the broad overview is that there exists some routing algorithm in every router which populates the table. Different routers talk to each other to exchange information on their routing algorithms. More recently there has been a move towards **software-defined networking (SDN)** which basically separates the routing algorithm/control plane out of the routers and moves it to some data center. This data center can then decide the forwarding tables for many routers.

# Terminology

Packets at this level are known as **datagrams**. The network layer doesn't really make any promises about delivery of packets (so called best-effort delivery). There have been alternatives proposed but it turns out that this model has good enough to allow the current internet to flourish. Packet switch is a generic term for a device that moves packets from an input interface to an output interface. Packet switches that make these moves based on IP headers are called routers. Packet switches that do this based on link layer information are called link-layer switches.

There are two types of networks: connectionless (or datagram) and connection-oriented (or virtual circuit). Our IP internet is a datagram network. In a connection-oriented network, the sender gets something called a virtual connection ID (VCI) after a connection is established and uses that for the header, rather than the destination address. This means routers have another table which maps VCIs to output interfaces. VCIs need to be globally unique. Representing a unique ID for every TCP connection in the world would take a lot of bits so we make the VCI unique for each link. Routers then swap out the label at each step and the whole chain of smaller VCIs adds up to one globally unique VCI. Replacing the destination with this VCI reduces header length. Virtual circuits require at least one RTT for a connection to be established, more state (to hold VCI tables), and they aren't resilient to failure (they'll need to form a new connection). But on the other hand, they guarantee that all packets will take the same path so everything will arrive in order and you can get some performance guarantees (e.g., the destination exists and has adequate buffer space). We're not going to talk any more about connection-oriented networks, I just wanted to briefly acknowledge their existence.

# IP

The IPv4 datagram header begins with a 4-bit version number used to help routers as different versions use different datagram formats. This is followed by a 4-bit header length saying where the payload actually begins. Most datagrams do not contain any options (see below) which leads to the full header being 20 bytes. Next comes an 8-bit type of service (TOS) which basically explains what the IP packet is being used for (e.g., FTP or real time voice). Two of the TOS bits can be used to inform parties that the network is congested (although it's my understanding that this is rarely used). Next comes a 16-bit number which represents the size of the IP datagram in bytes. In practice, IP datagrams are rarely more than 1,500 bytes.

Next comes a 16-bit identifier, 3 bits of flags, and a 13-bit fragmentation offset. These are all used for fragmenting packets. Following that comes an 8-bit TTL. At every router, this is decremented by 1 and if it reaches 0, the packet is dropped. Next is an 8-bit protocol number (6 for TCP, 17 for UDP) which basically tells the receiving host what the datagram is destined for. While port numbers connect the application and transport layer, this number connects the transport and network layer. Then comes a 16-bit checksum calculated by adding every 2-byte piece of the IP header using 1s complement. Note that data is included in this checksum and it must be recomputed at every router as the TTL changes at each step. If the checksum fails, routers usually drop the datagram. The header usually ends with the sender and recipient's IP addresses. In rare cases, options could come after the IP addresses. This isn't common and this was abolished in IPv6. Finally, we have the actual data being transported. Most TCP packets therefore have a 20-byte header along with another 20-bytes of IP header.

We fragment datagrams because not all links can carry packets of the same size. Ethernet carries packets of size 1,500 bytes but some WANs can only transport 576 bytes. So if we need to create smaller datagrams, the router breaks them up and stamps each new datagram with the same destination and all. The identification level in the header is like a sequence number and allows fragments of the same original datagram to be recombined. We use one bit of the flags as a 1 for all packets except the last in a fragment series. Finally, the offset field allows us to check that no fragments were lost. Note that if a single fragment fails to arrive, the whole segment must be dropped.

# Addresses

If we have, say, three networks (e.g., 223.1.1.x, 223.1.2.x, and 223.1.3.x) all connected through one router, we refer to these as **subnets**. In the 223.1.1.x network, we assign the IP address 223.1.1.0/24. The "/24" is our **subnet mask** (called slash-24 notation) and it means that the first 24 bits of every IP must be the same (e.g., take the form 223.1.1.x). In theory, various subnets all at one institution could have very different IPs but in practice they are almost always very similar (like in the example in this paragraph). Another notation would be to have a mask of say 192.168.187.0 with mask 255.255.255.128. Writing this out in binary, the 1s are the fixed bits. So in this case, the final 7 bits can change. So our IPs are 192.168.187.0-192.168.187.127

The Internetâ€™s address assignment strategy is known as **Classless Interdomain Routing (CIDR** - pronounced cider). This is a generalization of our subnet addresses above. Things take the form a.b.c.d/x where the first x bits identify the network and are known as the **prefix** of the address. We typically give institutions a range of IP address and therefore, all routers outside of the institution need to only consider the first x bits of the destination, simplifying the routers' forwarding tables. In fact, we could even link multiple institutions together like this in a process called **address aggregation** (i.e., they all share the same prefix and the outer world doesn't need to know anything about how messages are handled internally). The classless in CIDR refers to the old system of classifying IP addresses. Everything had 8, 16, or 24-bit prefixes which made them Class A, Class B, or Class C networks respectively. This system was ended because 254 IPs (2 are reserved for special use) wasn't enough for many institutions so they were upgraded to Class B with more than 65,000 available IPs. This was rapidly depleting the supply of IPs as few institutions used this many addresses.

If a message is sent to 255.255.255.255, then this is a broadcast message and it's sent to all devices on the subnet. Routers can optionally forward the message to neighboring subnets but in practice they don't do this.

A non-profit called the Internet Corporation for Assigned Names and Numbers (ICANN) is in charge of giving IP addresses out to ISPs. (Also, they handle DNS root servers and handle domain name disputes.) In general, they give blocks of IP addresses to more specific, regional groups (called RIRs) who in turn give them to ISPs. These ISPs then sell them to institutions.

## DHCP

When a network is set up, administrators typically give the routers their IP addresses. Then they allow the **Dynamic Host Configuration Protocol (DHCP)** to automatically assign IP addresses to hosts on the network. Hosts can either be assigned the same IP every time or they can be given temporary IPs. DHCP also allows a host to learn additional information, such as its subnet mask, the address of its first-hop router (often called the default gateway), and the address of its local DNS server. In the simplest case, each subnet will have a DHCP server which clients can talk to, if not then the router will know the address of the DHCP server and connect the client.

All in all this is a four step process for a new host. The first step is the server discovery step. The host sends a DHCP discovery message (UDP, port 67). This message is sent to 255.255.255.255 and from 0.0.0.0. In step two, the server will reply with a DHCP offer message. This message is sent to 255.255.255.255. It is possible that multiple servers will reply with offers which allows the host to pick. Each offer contains the proposed IP, the network mask, and the lease time (typically hours to days). Step 3, the client sends a DHCP request message echoing back the chosen IP. Finally, the server replies with a DHCP ACK. There is a mechanism that exists to allow hosts to extend their IP leases. Because your IP changes when you change subnets, a TCP connection cannot be maintained while a host is changing networks.

## NAT

Of course, giving every home or small office a set of IP addresses means we would quickly run out (and it would make setting up your home's WiFi difficult). So how do we deal with this? Well, the approach that's seeing more and more use is called **network address translation (NAT)**. Basically, your home's WiFi network looks to the rest of the internet like a single device. All hosts on the network are given a reserved IP address (e.g., 10.0.0.1) so they can distinguish themselves. If a host sends something to the wider Internet, the router will record the internal IP and port number along with the destination IP and port number in a **NAT translation table**. Then the router replaces the source IP with its own IP and changes the port to whatever port its using and sends the packet off. When a packet is received, the router checks its NAT translation table and rewrites with the correct internal IP and port and forwards it along. In this way, your device thinks that it has a real IP address and is connecting to the wider internet directly, but in reality, the router is intercepting everything.

As an aside, the router gets its public IP address using the ISPs DHCP server. There are a few downsides to NAT; for example, it's hard to run a server because of NAT's use of ports as an addressing scheme (although there are a few ways around this). Some purists also don't like NAT because it violates how we expect the web to work (with host-to-host connections and routers merely passing packets along).

# IPv6

In 2011, the last portion of IPv4 addresses was given to a regional registry. In recent years, the registries gave out all of those addresses. So IPv6 was created (starting way back in the 90s) to give us more addresses. (As an aside, it's not called IPv5 because there was an experimental protocol that was never really deployed that could be considered IPv5 even though it wasn't called that but they wanted to avoid confusion.) IPv6 replaces 32-bit addresses with 128-bit addresses so we should never run out of IPv6 addresses. It also created a new thing called an anycast address which lets a host send a packet to a chosen group of hosts rather than just a single host. Also, a lot was dropped from the header so that even with 128-bit addresses, the header is only 40 bytes (there is no longer an options field so it's a set 40 bytes).

The header is now a 4-bit version number (which takes the value 6 for IPv6). Note that setting this value to 4 will not make this a valid IPv4 datagram which is pretty inconvenient. Next is an 8-bit value called the traffic class which is basically the same as IPv4's TOS (it allows for prioritization of certain packets). Next comes a 20-bit flow label. Flows aren't totally defined yet but more for future use. Basically, we can designate certain things as flows like maybe video streaming or the traffic of people paying for better internet and maybe we can design networks to do something with that information. Next is a 16-bit value specifying the number of bytes in the payload. Then there's an 8-bit value called next header which specifies what application the data is being delivered to (e.g., TCP or UDP). This field takes the same values as the IPv4 field. Next comes the hop limit which is just the TTL and decremented by one at each router. Then comes the sender address followed by the destination address.

IPv6 doesn't allow for fragmentation (hence why that's been dropped from the header). If a host sends too large of a datagram then the router will simply drop it and send a notice to the sender that the packet was too large. Fragmentation is a costly process so removing that from the network considerably speeds up IP forwarding in the network. There's also no checksum because the designers thought there was enough redundancy in the checksums present in the transport and link layers. This also speeds up IP forwarding because in IPv4 the checksum had to be recomputed at every router. The options field has also been dropped but the options themselves remain. Rather then sending a TCP segment in a datagram, we could simply send the options we want to use.

Unfortunately, IPv4 routers can't handle IPv6 packets. The solution has been an approach called **tunneling**. Basically, until the whole network has been upgraded if we encounter a router which can only handle IPv4, we place the whole IPv6 datagram inside an IPv4 datagram, set the destination to the next router which can handle IPv6, and set the protocol number to 41 (this tells the receiving router to open the datagram and forward the IPv6 datagram inside). Adoption was slow but is picking up. It's just really hard to change network layer protocols because of all the physical infrastructure.

# Conclusion

Hopefully this gives some idea of how IP works. In the next blog post, I plan to focus on how IP packets are actually routed. That should result in a more zoomed out discussion of what is written here. 
